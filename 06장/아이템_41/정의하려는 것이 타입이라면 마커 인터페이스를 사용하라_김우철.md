## 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라

### 마커 인터페이스란

- 마커 인터페이스해당 인터페이스를 구현한 클래스가 어떤 “마커” 또는 “태그”를 가지고 있음을 나타내는 역할을 한다.

```java
package java.io;

public interface Serializable {
}

---
package java.io;

public interface Cloneable {
}
```

- Serializable는 객체가 직렬화 될 수 있음을 나타낸다.
- Cloneable는 객체가 복제될 수 있음을 나타낸다.

### 마커 인터페이스가 마커 애너테이션보다 나은 점

1. 컴파일 타임에서 타입 체크가 가능하며 특정 메서드에서 마커 인터페이스를 구현한 객체들만 받을 수 있다.

```java
public void process(Serializable obj) {
    // 이 메서드는 Serializable을 구현한 객체들만 받을 수 있음
}
```

2. 적용 대상을 더 세밀하게 제어할 수 있다.
- 마커 애너테이션에서 @Target는 특정한 클래스 혹은 인터페이스 등에 적용할 수 없다.
- 특정 인터페이스를 구현한 클래스에만 적용하고 싶은 마커가 있으면 마커 인터페이스를 구현하기만 하면 된다.

- 반대 의견이 있을 수 있지만 Set 인터페이스도 제한적인 마커 인터페이스로 볼 수 있다.
  - 마커 인터페이스 처럼 추가적인 메서드를 정의하지 않고, 특정한 규약(중복을 허용하지 않는 점, 순서 보장 안하는 점 등)만 나타낸다.
  - 제한 적인 이유는 add, equals, hashCode 등 Collection의 메서드 몇개의 규약을 살짝 수정했기 때문이다.

- 마커 애너테이션이  마커 인터페이스보다 나은 점으로는 거대한 애너테이션 시스템의 지원을 받을 수 있다.
  - 리플렉션을 통해 런타임에서 특정 어노테이션이 적용된 메서드를 찾는다던가
  - 애너테이션에 값을 부여 하던가
  - 등등..
-

### 마커 애너테이션과 마커 인터페이스 적절한 사용처

- 마커를 클래스나 인터페이스에 적용해야 한다면 “이 마킹이 된 객체를 매개변수로 받는 메서드를 작성할 일이 있나요?”
  - 있으면 마커 인터페이스
  - 없으면 마커 애너테이션

- 애너테이션을 적극 활용하는 프레임워크에선 마커 애너테이션을 사용하여 일관성을 지키자

### 결론

- 새로 추가하는 메서드 없이 단지 타입 정의가 목적이라면 마커 인터페이스를 사용하자.
- 클래스나 인터페이스 외에(모듈, 패키지, 지역변수 등) 프로그램 요소에 마킹해야 하거나, 애너테이션을 적극 활용하는 프레임워크에선 마커 애너테이션을 사용하자.
- ElementType.TYPE 마커 애너테이션을 사용하고 있다면 마커 인터페이스 전환을 고려해보자.