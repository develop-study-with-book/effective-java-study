## 아이템6 불필요한 객체 생성을 피하라

객체를 재사용해야 하는 이유
매번 생성하면 **메모리 사용 증가 및 성능 저하**

불변객체(아이템17)는 내부 정보가 고정되어 있기 때문에 언제든 재사용 가능
이런 것 처럼 재사용 할 수 있는 객체는 재사용하는 게 성능상 유리함.


그렇다면 다음 코드를 작성하면 안되는 이유는?
```java
String s = new String("bikini");  //String은 불변인데도 불구하고 새로운 객체를 생성하여 사용
```
하나의 String "bikini" 객체를 재사용하는 것이 아닌 새로운 String "bikini" 객체를 생성함.

생성비용이 비싼 객체라면 캐싱하여 재사용하는 것을 권장.

하지만 본인이 사용하는 객체가 비싼 객체인지 **모르고 사용**하는 경우가 많다.  

자주 사용하는 메서드 중 String의 matches를 사용한 예시를 보자.

```java(책 예시)
static boolean isRomanNumeral(String s) {  
  return s.matches("^(?=.)M*(C[MD]|D?C{0,3})"
          + "(X[CL]|L?X{0.3})(I[XV]|V?I{0,3})$");
}
```
String.matches는 정규표현식으로 문자열 형태를 확인하는 가장 쉬운 방법이다.  

하지만 위와 같이 사용할 경우, 자주 반복하여 사용할 시 성능에 문제가 될 수 있다.  

이 메서드는 내부에서 정규표현식용 Pattern 인스턴스를 생성하고 사용 후 바로 버려져 가비지 컬렉션 대상이 된다.  
하지만 이 Pattern은 입력받은 정규표현식에 해당하는 유한상태머신을 만들기 때문에 인스턴스 생성 비용이 높다.  
따라서 (불변)Pattern을 클래스 초기화(정적 초기화) 과정에서 직접 생성해 캐싱해두고, 나중에 재사용하는 것이 좋다.

해당 정규표현식은 매번 같은 Pattern 인스턴스를 생성하기 때문에 여러번 생성할 이유가 없다.(재사용을 통한 성능향상 가능)
```java
public class RomanNumerals {
  private static final Pattern ROMAN = Pattern.complie(
        "^(?=.)M*(C[MD]|D?C{0,3})"
          + "(X[CL]|L?X{0.3})(I[XV]|V?I{0,3})$");

  static boolean isRomanNumeral(String s) {
    return ROMAN.matcher(s).matches();  //미리 만들어둔 불변 Pattern을 사용하여 비교할 문자에 대한 Matcher를 생성한 후 matches메서드를 통해 일치여부 확인 
  }
}
```

불필요한 객체를 만들어내는 또 다른 예로 오토박싱(auto boxing)을 들 수 있다.

오토박싱이란? 기본 타입과 박싱된 기본 타입을 섞어 쓸 때 자동으로 상호 변환해주는 기술  
- 기본타입 : int, double, boolean 등
- 박싱된 기본타입 : Integer, Double, Boolean 등
- 참조 타입 : String, List 등 기본타입, 박싱된 기본타입 외의 모든 타입

기본타입 vs 박싱된 기본타입
1. 기본 타입은 값만 가지고 있으나, 박싱된 기본 타입은 값에 더해 식별성을 갖는다. 기본타입은 값만 비교가능하나, 박싱된 기본타입은 주소값도 비교가능.
2. 기본 타입의 값은 언제나 유효하나, 박싱된 기본 타입은 유효하지 않은 값인 null을 가질 수 있다.
3. 기본 타입이 박싱된 기본 타입보다 시간과 메모리 사용면에서 더 효율적이다.

오토박싱은 객체생성비용과 Heap영역에 생성되기에 메모리 참조 비용이 발생하여 성능에 문제가 생길 수 있으니 주의해서 사용하자.

다음은 오토박싱을 통해 성능에 문제가 되는 예시다
```java
private static long sum() {
  Long sum = 0L;        // 박싱된 기본타입 Long을 사용
  for (long i = 0; i <= Integer.MAX_VALUE; i++) {
    sum += i;           //Long과 long을 계산하기 위해 long i를 오토박싱함(Long 생성)

  return sum;
}
```

또 다른 예시, ArrayList를 생성할 경우 생성하는 객체의 크기를 충분히 안다면 초기 크기를 선언해줘야한다.

ArrayList는 배열에 값이 추가될 때 처음 기본 용량 10(DEFAULT_CAPACITY = 10)이 적용된 후 사이즈가 1.5배씩 증가한다. (참조2)  
따라서 만약 사이즈가 최소 100인 배열을 사이즈를 명시하지 않고 사용한다면,  
" 0 -> 10 -> 15 -> 22 -> 33 -> 49 -> 74 -> 111 " 이런 식으로 배열의 크기를 늘리면서 배열을 생성함.  
100이라는 사이즈를 명시해주면 한 번만 생성할 것을 8번이나 생성해줌.  
사이즈를 비교하는 조건문까지 포함되기 때문에 단순히 8개의 배열을 생성하는 것 이상으로 비쌈.  

---
#### 결론

사용하는 객체의 내부 구조나 원리를 알아야 함.  
위와 같은 케이스들을 평소에 알아두면 성능을 조금이나마 개선할 수 있는 포인트들을 알게 된다정도로 생각됨.  
결론적으로 혼자서 하기엔 현실적으로 어려우니 관련 내용을 주위사람들과 공유하거나 이런 도서를 챙겨봐야 한다.  

---
**객체 생성이 비싸다는 기준**이 무엇인가? 명확한 기준이 없다.

'The cost of object creation in Java, including garbage collection'글 (참조1)에서는 
일반적으로 자바에서의 객체 생성 비용은 생각보다 비싸지 않다는 반론을 제기함.
따라서 객체생성을 방지하는 코드를 삽입하기 보단 객체를 그냥 생성하고 그 외의 부분(쉽게 성능을 올릴 수 있는 명확한 부분)에서 리팩토링을 하는 것이 먼저다.

> 대부분의 객체와 같이 수명이 짧은 객체를 생성하는 데 드는 비용(이 특정 테스트 환경에서)은 3.6ns에 불과합니다. 서버가 요청당 1,000개의 개체를 생성하는 것뿐이라면 초당 > 최대 280,000개의 요청을 처리할 수 있습니다. 객체 생성이 요청을 처리하는 데 필요한 다른 작업에 비해 성능에 눈에 띄는 영향을 미칠 가능성은 거의 없습니다.

이 내용을 참고한다면, 대부분 큰 문제가 없으니 정말로 성능에 문제가 되는 특이 케이스들만 신경을 써주면 된다.

---

[참조]
1. 자바에서 객체 생성 비용 : https://www.bettercodebytes.com/the-cost-of-object-creation-in-java-including-garbage-collection/
2. ArrayList 배열 크기 증가 : https://chunsubyeong.tistory.com/82