## 네이티브 메서드는 신중히 사용하라

### 네이티브 메서드

- 자바 네이티브 인터페이스는 자바 프로그램이 네이티브 메서드를 호출하는 기술이다.
- 네이티브 메서드란 C나 C++같은 네이티브 프로그래밍 언어로 작성한 메서드를 말한다

### 네이티브 메서드의 쓰임새

#### 1.레지스트리 같은 플랫폼 특화 기능을 사용

#### 2.네이티브 코드로 작성된 기존 라이브러리를 사용

#### 3.성능 개선을 목적으로 해당 영역만 따로 네이티브 언어로 작성

### 현 시대의 네이티브 메서드의 필요성

- 플랫폼 특화 기능을 활용하려면 네이티브 메서드를 사용해야 한다
- 자바가 발전하면서 OS 같은 하부 플랫폼의 기능들을 점차 흡수하고 있어 네이티브 메서드의 사용은 줄어들고 있다

### 성능 개선의 목적으로는 권장하지 않는다

- 현 시대의 자바는 다른 플랫폼에 견줄만한 성능을 보인다
- java.math가 처음 추가된 자바 1.1 시절 BigInteger는 C로 작성한 고성능 라이브러리에 의지했다.
- 자바3부터 순수 자바로 다시 구현되면서 튜닝 결과, 원래의 네이티브 구현보다도 더 빨라졌다.

### 네이티브 메서드의 심각한 단점

- 네이티브 언어가 안전하지 않으므로(아이템 50) 네이티브 메서드를 사용하는 애플리케이션도 메모리 훼손 오류로부터 더 이상 안전하지 않다.
- 네이티브 언어는 자바보다 플랫폼을 많이 타서 이식성도 낮고, 디버깅도 어렵다. 잘못 사용하면 속도도 더 느려진다.
- 가비지 컬렉터가 네이티브 메모리는 자동 회수하지 모하고, 심지어 추적조차 할수 없다.(아이템 8)
- 자바 코드와 네이티브 코드의 경계를 넘나들 때마다 비용도 추가된다
- 네이티브 메서드와 자바 코드 사이의 ‘접착 코드’를 작성해야 하는데 귀찮다.

#### 네이티브 메서드 사용 예시

1. **네이티브 메서드 선언한 자바 코드 작성**

```java
public class NativeExample {
    // 네이티브 메서드 선언
    public native String getGreeting();

    // 네이티브 라이브러리 로드
    static {
        System.loadLibrary("NativeLib");
    }

    public static void main(String[] args) {
        NativeExample example = new NativeExample();
        // 네이티브 메서드 호출
        String greeting = example.getGreeting();
        System.out.println("Greeting from native code: " + greeting);
    }
}
```

**2. 네이티브 헤더 파일 생성**

Java 컴파일 후 javac 명령어를 사용하여 클래스 파일을 생성한 뒤, javah를 사용해 헤더 파일을 생성합니다.

```java
javac NativeExample.java
javah -jni NativeExample
```

```java
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class NativeExample */

#ifndef _Included_NativeExample
#define _Included_NativeExample
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     NativeExample
 * Method:    getGreeting
 * Signature: ()Ljava/lang/String;
 */
JNIEXPORT jstring JNICALL Java_NativeExample_getGreeting
  (JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif
```

**3. C 코드 (네이티브 메서드 구현)**

헤더 파일을 기반으로 네이티브 메서드를 구현합니다.

- **Java에서 선언한 네이티브 메서드**의 “스펙”을 정의한 헤더 파일을 참고해서, C/C++에서 해당 메서드의 실제 동작을 구현한

```c
#include "NativeExample.h"
#include <stdio.h>
#include <string.h>

// 네이티브 메서드 구현
JNIEXPORT jstring JNICALL Java_NativeExample_getGreeting(JNIEnv *env, jobject obj) {
    const char *greeting = "Hello from C!";
    return (*env)->NewStringUTF(env, greeting);
}
```

**4. 네이티브 라이브러리 컴파일**

C 코드를 컴파일하여 네이티브 라이브러리를 생성합니다. 플랫폼에 따라 다른 명령어를 사용합니다.

```c
gcc -shared -o libNativeLib.dylib -I"$JAVA_HOME/include" -I"$JAVA_HOME/include/darwin" NativeExample.c
```

**5. 실행**

Java 프로그램을 실행합니다. NativeLib 라이브러리가 올바르게 로드되고, 네이티브 메서드가 호출됩니다.

### 핵심 정리

```
💡
네이티브  메서드를 아주 조심해서 사용해라. 성능 개선도 거의 못해준다. 
어쩔 수 없이 사용해야 한다면 테스트를 철저히 해라.
```