## 아이템 21. 인터페이스는 구현하는 쪽을 생각해 설계하라

#### 인터페이스에 메서드 추가

- 자바8 이전
  - 인터페이스에 메서드를 추가시 기존 구현체를 깨뜨림(만약 우연히 구현체에 해당 메서드가 있을 경우 예외).
- 자바8 이후
  - 인터페이스에 디폴트 메서드를 추가하여 기존 구현체에 메서드를 추가하지 않아도 컴파일 오류 발생하지 않음.

**그렇다면 디폴트 메서드를 사용하면 문제가 없는가?**  
기존 구현체들과 문제없이 연동된다는 보장은 없음.  
왜냐하면, 자바 7까지의 모든 클래스가 "현재의 인터페이스에 새로운 메서드가 추가될 일은 영원히 없다"고 가정하고 작성됐기 때문.  
디폴트 메서드는 구현 클래스에 대해 협의 없이 단순 '삽입'된다.  

자바8에선 핵심 컬렉션 인터페이스들에 다수의 디폴트 메서드가 추가됨. 람다 활용을 위함.  
자바 라이브러리의 디폴트 메서드는 코드 품질이 높고 범용적이라 대부분 문제 없지만, **생각할 수 있는 모든 상황에서 불변식을 해치지 않는 디폴트 메서드를 작성하긴 어렵다.**  

예) 자바 8의 Collection 인터페이스에 추가된 removeIf 메서드  

removeIf 메서드는 주어진 불리언 함수(predicate; 프레디키트)가 true를 반환하는 모든 원소를 제거한다.  
디폴트 구현은 반복자를 이용해 순회하면서 각 원소를 인수로 넣어 프레디키트를 호출하고, 프레디키트가 true를 반환하면 반복자의 remove 메서드를 호출해 그 원소를 제거한다.  

```java
default boolean removeIf(Predicate<? super E> filter) {
  Objects.requireNonNull(filter);
  boolean result = false;
  for (Iterator<E> it = iterator(); it.hasNext(); ) {
    if (filter.test(it.next())) {
      it.remove();
      result = true;
    }
  }
  return resutl;
}
```

이 코드는 굉장히 범용적이지만, 현존하는 모든 Collection 구현체와 잘 어우러지는 것은 아니다.  
예) org.apache.commons.collections4.collection.SynchronizedCollection  

자바 플랫폼 라이브러리에서는 이런 문제를 예방하기 위해 다음과 같은 조치를 취했다.  
구현한 인터페이스의 디폴트 메서드를 재정의하고, 다른 메서드에서는 디폴트 메서드를 호출하기 전에 필요한 작업을 수행하도록 했다.

아파치의 SynchronizedCollection 클래스는 지금도 활발히 관리되고 있지만, 이 책을 쓰는 시점엔 removeIf 메서드를 

- 디폴트 메서드는 (컴파일 성공하더라도) 기존 구현체에 런타임 오류를 일으킬 수 있다. 
- 기존 인터페이스에 디폴트 메서드로 새 메서드를 추가하는 일은 꼭 필요한 경우가 아니면 피해야 한다.
- 반면, 새로운 인터페이스를 만드는 경우라면 표준적인 메서드 구현을 제공하는 데 아주 유용한 수단이며, 그 인터페이스를 더 쉽게 구현해 활용할 수 있게끔 해준다.
- 디폴트 메서드는 인터페이스로부터 메서드를 제거하거나 기존 메서드의 시그니처를 수정하는 용도가 아님을 명심해야 한다.

---
## 결론
- 자바 8 이후 디폴트 메서드가 생겼지만, 인터페이스 설계할 땐 여전히 주의하자.
- 새로운 인터페이스라면 릴리스 전에 테스트를 통해 실제 구현될 형태를 확인하자.
- 인터페이스를 릴리스한 후엔 결함을 수정하는 게 힘들다. 